<h5>Juan David Velez 2220231030</h5> 
<h5>Isis Sanchez  2220231019</h5> 
<h5>Mariana Rodríguez 2220231099</h5>


<h1><strong>Pruebas de Software</strong></h1>
<h2>¿Qué es y para qué sirve?</h2>
Las pruebas de software son actividades realizadas para evaluar y verificar la calidad de un software antes de su lanzamiento. Su objetivo es identificar errores y defectos, garantizar el cumplimiento de requisitos y mejorar la calidad del software. Las pruebas ayudan a reducir riesgos, asegurar la estabilidad y rendimiento del software, y mejorar la satisfacción del cliente. También permiten corregir problemas en etapas tempranas, reduciendo costos y mejorando la confiabilidad del software.
<h2>Tipos de pruebas de software</h2>
<h3><strong>Pruebas de unidad:</strong></h3> Evalúan componentes individuales del software de forma aislada para verificar su funcionamiento correcto. <br>
<h3><strong>Pruebas de integración:</strong></h3> Verifican la interoperabilidad y comunicación entre los componentes del software cuando se combinan. <br>
<h3><strong> Pruebas de sistema:</strong></strong></strong></h3> Evalúan el software en su totalidad para asegurar que cumple con los requisitos establecidos y evaluar su funcionalidad, rendimiento, seguridad y usabilidad. <br>
<h3><strong>Pruebas de aceptación:</strong></strong></h3> Realizadas por el cliente o usuario final para validar que el software cumple con los requisitos y expectativas establecidos. <br>
<h3><strong>Pruebas de regresión:</strong></h3> Verifican que las modificaciones o actualizaciones del software no hayan introducido nuevos errores y que las funcionalidades previamente probadas sigan funcionando correctamente. <br>
<h3><strong>Pruebas de rendimiento:</strong></h3>  Evalúan el desempeño y la capacidad del software bajo diferentes condiciones de carga, tiempo de respuesta y utilización de recursos. <br>
<h3><strong>Pruebas de seguridad: </strong></h3> Comprueban la resistencia del software a ataques y vulnerabilidades, para garantizar la protección de los datos y la integridad del sistema. <br>
<h3><strong>Pruebas de usabilidad:</strong></h3> Se enfocan en la facilidad de uso y la experiencia del usuario, evaluando aspectos como la navegación y la interfaz de usuario. <br>
<h3><strong>Pruebas de estrés:</strong></h3> Se realizan para evaluar el comportamiento del software bajo condiciones extremas de carga, volumen de datos o recursos limitados. <br>
<h1><strong>Patrones de Desarollo GOF</strong></h1>
Los patrones de desarrollo GOF (Gang of Four) son un conjunto de 23 patrones de diseño de software ampliamente reconocidos y documentados en el libro "Design Patterns: Elements of Reusable Object-Oriented Software" escrito por Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides. Estos patrones se utilizan para resolver problemas comunes en el diseño de software orientado a objetos y promueven la reutilización, flexibilidad y mantenibilidad del código. 
<br>
<br>
Los patrones de desarrollo GOF proporcionan soluciones probadas y estructuradas para problemas comunes que surgen durante el diseño de software. Estos patrones capturan las mejores prácticas y la experiencia acumulada de los desarrolladores de software a lo largo del tiempo.

<h2>Los patrones de desarrollo GOF se dividen en tres categorías principales::</h2>

<h3>Patrones de creación: </h3>
* Singleton (Singleton): Garantiza que una clase solo tenga una instancia y proporciona un punto de acceso global a ella.

*Factory Method (Método de fábrica): Define una interfaz para crear objetos, pero permite a las subclases decidir qué clase instanciar.

*Abstract Factory (Fábrica abstracta): Proporciona una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.

*Builder (Constructor): Permite construir objetos complejos paso a paso, separando la construcción de su representación.

*Prototype (Prototipo): Permite crear nuevos objetos a partir de un prototipo existente, clonando la instancia existente.

<h3> Patrones de estructura: </h3> 
*Adapter (Adaptador): Permite que interfaces incompatibles trabajen juntas mediante la conversión de la interfaz de una clase en otra interfaz esperada por el cliente.

*Decorator (Decorador): Agrega funcionalidad adicional a un objeto dinámicamente, sin modificar su estructura básica.

*Composite (Compuesto): Permite tratar a un grupo de objetos como uno solo, utilizando una estructura en forma de árbol.

*Proxy (Proxy): Proporciona un sustituto o representante de otro objeto para controlar su acceso.

<h3>Patrones de comportamiento (Behavioral Patterns):</h3>  *Observer (Observador): Define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia su estado, todos los objetos dependientes son notificados y actualizados automáticamente.

*Strategy (Estrategia): Permite definir una familia de algoritmos, encapsulándolos y haciéndolos intercambiables. Los algoritmos pueden variar independientemente de los clientes que los utilizan.

*Template Method (Método de plantilla): Define el esqueleto de un algoritmo en una clase base, delegando ciertos pasos a las subclases.

*Iterator (Iterador): Proporciona un modo uniforme de acceder a los elementos de una colección sin exponer su implementación subyacente.

*State (Estado): Permite que un objeto altere su comportamiento cuando su estado interno cambia.
